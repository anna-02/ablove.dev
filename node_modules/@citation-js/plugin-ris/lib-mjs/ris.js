function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
import { util } from '@citation-js/core';
import config from './config.json';
import { SPECS } from './spec/index.js';
import CONVERTERS from './converters.js';
import DATA_TYPES from './dataTypes.json';
const LINE_MATCH = /^[A-Z][A-Z0-9] {2}-( |$)/;
const LINE_SPLIT = / {2}-(?: |$)/;
const TRANSLATORS = new Map();
function prepareTranslator(spec) {
  if (!TRANSLATORS.has(spec)) {
    for (const mapping of spec) {
      if (mapping.target === 'issued' && !Array.isArray(mapping.source)) {
        mapping.convert = CONVERTERS.YEAR;
        continue;
      }
      if (mapping.target in DATA_TYPES) {
        mapping.convert = CONVERTERS[DATA_TYPES[mapping.target]];
      }
      if (mapping.convert && mapping.convert.keepAll === true) {
        continue;
      }
      if (Array.isArray(mapping.source)) {
        if (mapping.convert) {
          const {
            toSource,
            toTarget
          } = mapping.convert;
          mapping.convert = {
            toTarget(...args) {
              return toTarget(CONVERTERS.ANY.toTarget(...args));
            },
            toSource(...args) {
              return CONVERTERS.ANY.toSource(toSource(...args));
            }
          };
        } else {
          mapping.convert = CONVERTERS.ANY;
        }
      }
    }
    TRANSLATORS.set(spec, new util.Translator(spec));
  }
  return TRANSLATORS.get(spec);
}
export function parse(text) {
  const entries = [];
  let lastEntry;
  let lastTag;
  for (let line of text.split(/\r?\n/)) {
    line = line.trim();
    if (!LINE_MATCH.test(line)) {
      if (lastEntry && lastTag) {
        lastEntry[lastTag] += ' ' + line;
      }
      continue;
    }
    const [tag, value] = line.split(LINE_SPLIT);
    switch (tag) {
      case 'ER':
        lastEntry = undefined;
        lastTag = undefined;
        break;
      case 'TY':
        lastEntry = {};
        entries.push(lastEntry);
      default:
        if (Array.isArray(lastEntry[tag])) {
          lastEntry[tag].push(value);
        } else {
          lastEntry[tag] = lastEntry[tag] ? [lastEntry[tag], value] : value;
        }
        lastTag = tag;
    }
  }
  return entries;
}
export function parseOld(data) {
  return prepareTranslator(SPECS.old).convertToTarget(data);
}
export function parseNew(data) {
  return prepareTranslator(SPECS.new).convertToTarget(data);
}
export function parseMixed(data) {
  return prepareTranslator(SPECS.mixed).convertToTarget(data);
}
export function format(data, {
  type,
  format = type || 'text',
  spec
} = {}) {
  const outputSpec = spec || config.outputSpec;
  const translate = prepareTranslator(SPECS[outputSpec]).convertToSource;
  const entries = data.map(entry => translate(entry.type ? entry : _objectSpread(_objectSpread({}, entry), {}, {
    type: 'document'
  })));
  if (format === 'object') {
    return entries;
  }
  return entries.map(entry => {
    const tags = [];
    for (const tag in entry) {
      if (tag === 'TY') {
        continue;
      }
      tags.push(...[].concat(entry[tag]).map(value => `${tag}  - ${value.toString().replace(/(.{70})/g, '$1\n')}`));
    }
    tags.unshift(`TY  - ${entry.TY}`);
    tags.push('ER  - ');
    return tags.join('\n');
  }).join('\n');
}