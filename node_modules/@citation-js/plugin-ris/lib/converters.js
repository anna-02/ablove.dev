"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _date = require("@citation-js/date");
var _types = _interopRequireDefault(require("./spec/types.json"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const ISSN_REGEX = /^\d{4}-\d{3}[0-9Xx]$/;
const DOI_REGEX = /10(?:\.[0-9]{4,})?\/[^\s]*[^\s.,]/;
const CONVERTERS = {
  ANY: {
    toTarget(...values) {
      return values.find(Boolean);
    },
    toSource(value) {
      return [value];
    }
  },
  PAGE: {
    keepAll: true,
    toTarget(start, end) {
      return [start, end].filter(Boolean).join('-');
    },
    toSource(pages) {
      return pages.replace(/[-–—]/g, '-');
    }
  },
  ISBN: {
    toTarget(id) {
      return ISSN_REGEX.test(id) ? [id] : [undefined, id];
    },
    toSource(...ids) {
      return ids.find(Boolean);
    }
  },
  DATE: {
    toTarget(date) {
      return date && (0, _date.parse)(date.split('/').slice(0, 3).filter(Boolean).join('/'));
    },
    toSource(date) {
      if (!date['date-parts'] || !date['date-parts'][0]) {
        return undefined;
      }
      const parts = Array(4).fill('');
      date['date-parts'][0].forEach((part, index) => {
        parts[index] = part;
      });
      if (date.season) {
        parts[3] = date.season;
      }
      return parts.join('/');
    }
  },
  YEAR: {
    toTarget(year) {
      return isNaN(+year) ? {
        raw: year
      } : {
        'date-parts': [[+year]]
      };
    },
    toSource(date) {
      var _date$dateParts;
      return (_date$dateParts = date['date-parts']) === null || _date$dateParts === void 0 || (_date$dateParts = _date$dateParts[0]) === null || _date$dateParts === void 0 || (_date$dateParts = _date$dateParts[0]) === null || _date$dateParts === void 0 ? void 0 : _date$dateParts.toString();
    }
  },
  DATE_YEAR: {
    keepAll: true,
    toTarget(...dates) {
      return CONVERTERS.DATE.toTarget(CONVERTERS.ANY.toTarget(...dates));
    },
    toSource(date) {
      return [CONVERTERS.DATE.toSource(date), CONVERTERS.YEAR.toSource(date)];
    }
  },
  NAME: {
    toTarget(names) {
      return names && [].concat(names).map(name => {
        const parts = name.split(/, ?/);
        const [family, given, suffix] = parts;
        switch (parts.length) {
          case 3:
            return {
              family,
              given,
              suffix
            };
          case 2:
            return {
              family,
              given
            };
          case 1:
            if (family.indexOf(' ') === -1) {
              return {
                family
              };
            }
          default:
            return {
              literal: name
            };
        }
      });
    },
    toSource(names) {
      return names.map(({
        family,
        given,
        suffix,
        literal
      }) => {
        const parts = [family, given, suffix].filter(Boolean);
        return parts.length ? parts.join(', ') : literal;
      });
    }
  },
  KEYWORD: {
    toTarget(words) {
      words = [].concat(words);
      return words.join(',');
    },
    toSource(words) {
      return words.split(',');
    }
  },
  ID: {
    toSource(id) {
      return id.toString().slice(0, 20);
    }
  },
  TYPE: {
    toTarget(type) {
      return _types.default.RIS[type];
    },
    toSource(type) {
      return _types.default.CSL[type];
    }
  },
  DOI: {
    toTarget(doi) {
      return doi.match(DOI_REGEX)[0];
    },
    toSource(doi) {
      return doi.match(DOI_REGEX)[0];
    }
  }
};
var _default = exports.default = CONVERTERS;