function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
import wdk from '@larsgw/wikibase-sdk/commonjs/wikidata.org';
import { parse as fetch, parseAsync as fetchAsync } from './api.js';
import { parse as getUrls } from './id.js';
const SIMPLIFY_OPTS = {
  keepQualifiers: true,
  timeConverter: 'simple-day'
};
const FETCH_PLACE = {
  P17: null
};
const FETCH_PUBLISHER = {
  P740: FETCH_PLACE,
  P159: FETCH_PLACE
};
const FETCH_ADDITIONAL = {
  P50: null,
  P57: null,
  P58: null,
  P86: null,
  P98: null,
  P110: null,
  P162: null,
  P170: null,
  P175: null,
  P178: null,
  P371: null,
  P488: null,
  P655: null,
  P664: null,
  P1431: null,
  P1640: null,
  P1817: null,
  P2438: null,
  P5030: null,
  P921: {
    P50: null
  },
  P407: null,
  P364: null,
  P123: FETCH_PUBLISHER,
  P629: {
    P50: null,
    P123: FETCH_PUBLISHER
  },
  P437: null,
  P186: null,
  P179: {
    P98: null
  },
  P1433: {
    P4745: {
      P276: FETCH_PLACE
    }
  },
  P361: {
    P50: null
  }
};
function collectAdditionalIds(entity, needed) {
  const additionalIds = [];
  if (!needed) {
    return additionalIds;
  }
  entity._needed = Object.assign(entity._needed || {}, needed);
  for (const prop in entity.claims) {
    if (prop in needed) {
      for (const claim of entity.claims[prop]) {
        if (claim.value) {
          var _claim$value$id;
          additionalIds.push((_claim$value$id = claim.value.id) !== null && _claim$value$id !== void 0 ? _claim$value$id : claim.value);
        }
      }
    }
  }
  return additionalIds;
}
function completeResponse(entities, old) {
  if (!old) {
    const allIds = [];
    for (const id in entities) {
      const ids = collectAdditionalIds(entities[id], FETCH_ADDITIONAL);
      for (const id of ids) {
        if (!allIds.includes(id)) {
          allIds.push(id);
        }
      }
    }
    return allIds;
  }
  const ids = [];
  for (const id of old) {
    const entity = entities[id];
    if (!entity._needed) {
      continue;
    }
    for (const prop in entity.claims) {
      if (prop in entity._needed) {
        for (const claim of entity.claims[prop]) {
          if (claim.value && claim.value.id) {
            continue;
          }
          claim.value = entities[claim.value];
          ids.push(...collectAdditionalIds(claim.value, entity._needed[prop]));
        }
      }
    }
    delete entity._needed;
  }
  return ids;
}
function simplifyEntities(entities) {
  for (const id in entities) {
    if (entities[id].missing === '') {
      throw new Error(`Entity "${id}" not found`);
    }
  }
  const simplified = wdk.simplify.entities(entities, SIMPLIFY_OPTS);
  for (const id in entities) {
    const claims = entities[id].claims;
    if (claims.P348) {
      simplified[id].claims['P348:all'] = wdk.simplify.propertyClaims(claims.P348, _objectSpread(_objectSpread({}, SIMPLIFY_OPTS), {}, {
        keepNonTruthy: true,
        keepRank: true
      })).filter(claim => claim.rank !== 'deprecated');
    }
  }
  return simplified;
}
function initLoopState(entities, cache) {
  return {
    needed: completeResponse(cache),
    incomplete: Object.keys(entities)
  };
}
function filterIdsAndGetUrls(needed, cache) {
  const shouldFetch = needed.filter((id, i) => !(id in cache) && needed.indexOf(id) === i);
  return getUrls(shouldFetch);
}
function addItemsToCache(response, cache) {
  const {
    entities
  } = JSON.parse(response);
  Object.assign(cache, simplifyEntities(entities));
}
function updateLoopState(state, cache) {
  return {
    needed: completeResponse(cache, state.incomplete),
    incomplete: state.needed
  };
}
function finalizeItems(entities, cache) {
  return Object.keys(entities).map(id => cache[id]);
}
export function fillCache(entities) {
  const cache = simplifyEntities(entities);
  let state = initLoopState(entities, cache);
  while (state.needed.length) {
    const urls = filterIdsAndGetUrls(state.needed, cache);
    urls.map(url => addItemsToCache(fetch(url), cache));
    state = updateLoopState(state, cache);
  }
  return cache;
}
export function parse(entities) {
  const cache = fillCache(entities);
  return finalizeItems(entities, cache);
}
export async function fillCacheAsync(entities) {
  const cache = simplifyEntities(entities);
  let state = initLoopState(entities, cache);
  while (state.needed.length) {
    const urls = filterIdsAndGetUrls(state.needed, cache);
    await Promise.all(urls.map(async url => addItemsToCache(await fetchAsync(url), cache)));
    state = updateLoopState(state, cache);
  }
  return cache;
}
export async function parseAsync(entities) {
  const cache = await fillCacheAsync(entities);
  return finalizeItems(entities, cache);
}